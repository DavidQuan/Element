//old element classes:
/**
 *
 */
 func layerWithColor(){
     let l:CALayer = layer!
     //layer!.frame = CGRectInset(l.frame, 5, 5);
     //l.backgroundColor = NSColorParser.cgColor(NSColor.greenColor())
     layer!.backgroundColor = CGColorCreateGenericRGB(1.0, 0.0, 0.0, 1.0)
     //l.backgroundColor = UIColor.blueColor().CGColor
     l.borderWidth = 4
     l.cornerRadius = 8
     
     l.borderColor = NSColorParser.cgColor(NSColor.redColor())
     
     //l.borderColor = UIColor.redColor().CGColor
     
     l.shadowOpacity = 0.7
     l.shadowOffset = CGSizeMake(0, 3);
     l.shadowRadius = 5.0;
     l.shadowColor = NSColorParser.cgColor(NSColor.grayColor())
     l.shadowOpacity = 0.8;
 }
 
 /**
 *
 */
 func test(){
     let gradient = CAGradientLayer()
     gradient.frame = self.bounds
   
     let roundRect = CALayer()
     gradient.colors = [NSColor.redColor().CGColor,NSColor.greenColor().CGColor]
     
     roundRect.frame = self.bounds
     roundRect.cornerRadius = 6.0
     roundRect.masksToBounds = true
     roundRect.addSublayer(gradient)
     self.layer!.insertSublayer(roundRect,atIndex:0)
    
 }

/**
 *
 */
 func layerWithGradient(){
     Swift.print("layerWithGradient")
     //let l:CALayer = CALayer()
     
     let gradientLayer = CAGradientLayer()
     //layer!.addSublayer(gradientLayer)
     //layer!.insertSublayer(gradientLayer, atIndex: 0)
     //self.sendSubviewToBack(gradientLayer)
     Swift.print("self.bounds")
     Swift.print(self.bounds)
     gradientLayer.frame = CGRect(x: 64, y: 64, width: 160, height: 160)
     //gradientLayer.frame = self.bounds
     
     gradientLayer.colors = [
     ColorParser.nsColor(209.0, 0.0,  0.0).CGColor,
     ColorParser.nsColor(255.0,  102.0,  34.0).CGColor,
     ColorParser.nsColor(255.0, 218.0,  33.0).CGColor,
     ColorParser.nsColor(51.0, 221.0,  0.0).CGColor,
     ColorParser.nsColor(17.0,  51.0,  204.0).CGColor,
     ColorParser.nsColor(34.0,  0.0,  102.0).CGColor,
     ColorParser.nsColor(51.0,  0.0,  68.0).CGColor]

     //gradientLayer.colors = [NSColor.redColor().CGColor,NSColor.greenColor().CGColor]
     gradientLayer.startPoint = CGPoint(x: 0, y: 0)
     gradientLayer.endPoint = CGPoint(x: 0, y: 1)
     /*
     gradientLayer.startPoint = CGPointZero;
     gradientLayer.endPoint = CGPointMake(1, 1);
     
     */
     //gradientLayer.locations = [NSNumber(double: 0.0),NSNumber(double: 0.7)]
     
     
     
     //continue here, something is missing
     
     
     
     
     layer!.addSublayer(gradientLayer)
 }
 

 
 
 /**
 *
 */
 func addSubLayer(){
     let sublayer = CALayer()
     sublayer.backgroundColor = NSColor.orangeColor().CGColor
     sublayer.shadowOffset = CGSizeMake(0, 3);
     sublayer.shadowRadius = 5.0;
     sublayer.shadowColor = NSColor.blackColor().CGColor
     sublayer.shadowOpacity = 0.8
     sublayer.frame = CGRectMake(30, 30, 128, 192);
     layer!.addSublayer(sublayer)
 }
 /*
 * CAShapeLayer doesnt supoprt gradient, but might do with: CGContextDrawRadialGradient, no it doesnt
 */
 func makeLineLayer(layer:CALayer,_ a:CGPoint,_ b:CGPoint){
     let line = CAShapeLayer(layer: layer)//CAShapeLayer *line = [CAShapeLayer layer];
     let linePath = NSBezierPath()
     linePath.moveToPoint(a)
     linePath.lineToPoint(b)
     
     line.path = NSBezierPathParser.cgPath(linePath)
     
     line.fillColor = nil;
     line.opacity = 1.0;
     line.strokeColor = NSColor.redColor().CGColor
     
     layer.addSublayer(line)
     
     
     /*
     [linePath moveToPoint: pointA];
     [linePath addLineToPoint:pointB];
     
     
     */
 }

/**
* draws many shapes (works)
*/
func drawShapes(dirtyRect: NSRect){
    Swift.print(String(dirtyRect))
    let bPath:NSBezierPath = NSBezierPath(rect: dirtyRect)
    Swift.print("bPath: " + String(bPath))
    let fillColor = NSColor(red: 0.5, green: 0.0, blue: 0.5, alpha: 1.0)
    fillColor.set()
    bPath.fill()
    
    let borderColor = NSColor(red: 1.0, green: 0.0, blue: 0.0, alpha: 1.0)
    borderColor.set()
    bPath.lineWidth = 12.0
    bPath.stroke()
    
    let circleFillColor = NSColor(red: 0.0, green: 1.0, blue: 0.0, alpha: 1.0)
    let circleRect = NSMakeRect(dirtyRect.size.width/4, dirtyRect.size.height/4, dirtyRect.size.width/2, dirtyRect.size.height/2)
    let cPath: NSBezierPath = NSBezierPath(ovalInRect: circleRect)
    circleFillColor.set()
    cPath.fill()
}
/**
* Todo try to style two things above the other. If this isnt possible pursue the Layer idea
*/
func drawGradientRect(rect: NSRect){
    // Defining the shape
    let drawingRect = CGRectInset(rect,rect.size.width * 0.1,rect.size.height * 0.1);
    let cornerRadius : CGFloat = 20
    let bezierPath = NSBezierPath(roundedRect: drawingRect,xRadius: cornerRadius,yRadius: cornerRadius)
    // Define the gradient
    let startColor = NSColor.blackColor()
    let endColor = NSColor.whiteColor()
    let gradient = NSGradient(startingColor:startColor, endingColor:endColor)
    // Draw the gradient in the path
    gradient!.drawInBezierPath(bezierPath, angle: 90)
}
/**
*
*/
func drawRadialGradientCircle(rect:NSRect){
    let bounds = self.bounds
    let aGradient:NSGradient = NSGradient(startingColor: NSColor.yellowColor(), endingColor: NSColor.redColor())!
    
    let centerPoint:NSPoint = NSMakePoint(NSMidX(bounds), NSMidY(bounds))
    let otherPoint:NSPoint = NSMakePoint(centerPoint.x + 60.0, centerPoint.y + 60.0)
    let firstRadius:CGFloat = min( ((bounds.size.width/2.0) - 2.0),((bounds.size.height/2.0) - 2.0) )
    aGradient.drawFromCenter(centerPoint, radius:firstRadius, toCenter: otherPoint, radius: 2.0, options: 0/*NSGradientDrawingOptions*/)

    
}


class GradientCALAyer:CALayer{
    var origin: CGPoint?
    var radius: CGFloat?
    var locations: [CGFloat]?
    var colors: [CGColor]?
    
    override func drawInContext(ctx: CGContext) {
        super.drawInContext(ctx)
        if let colors = self.colors {
            if let locations = self.locations {
                if let origin = self.origin {
                    if let radius = self.radius {
                        var colorSpace: CGColorSpaceRef?
                        
                        var components = [CGFloat]()
                        for i in 0 ..< colors.count {
                            let colorRef = colors[i]
                            let colorComponents = CGColorGetComponents(colorRef)
                            let numComponents = CGColorGetNumberOfComponents(colorRef)
                            if colorSpace == nil {
                                colorSpace = CGColorGetColorSpace(colorRef)
                            }
                            for j in 0 ..< numComponents {
                                //let componentIndex: Int = numComponents * i + j
                                let component = colorComponents[j]
                                components.append(component)
                            }
                        }
                        
                        if let colorSpace = colorSpace {
                            let gradient = CGGradientCreateWithColorComponents(colorSpace, components, locations, locations.count)
                            CGContextDrawRadialGradient(ctx, gradient, origin, CGFloat(0), origin, radius, CGGradientDrawingOptions.DrawsAfterEndLocation)
                        }
                    }
                }
            }
        }
        
    }
}


    
    /**
    * for caLayers i think
    */
    func layerWidthRadialGradient(rect:CGRect){
       
            //CGContextRef context = UIGraphicsGetCurrentContext();
            
        /*
        size_t gradLocationsNum = 2;
        CGFloat gradLocations[2] = {0.0f, 1.0f};
        CGFloat gradColors[8] = {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.5f};
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, gradColors, gradLocations, gradLocationsNum);
        CGColorSpaceRelease(colorSpace);
        
        CGPoint gradCenter= CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2);
        float gradRadius = MIN(self.bounds.size.width , self.bounds.size.height) ;
        
        CGContextDrawRadialGradient (context, gradient, gradCenter, 0, gradCenter, gradRadius, kCGGradientDrawsAfterEndLocation);
        
        CGGradientRelease(gradient);
        */
        
    }